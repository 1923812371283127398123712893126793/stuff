local function extract_parts(encrypted_str)
    local separator_index
    for i = 1, #encrypted_str do
        local char = encrypted_str:sub(i, i)
        if char:match("[%p]") then -- Detects first punctuation mark (separator)
            separator_index = i
            break
        end
    end

    if not separator_index then return nil, nil end -- If no separator found, return nil
    local key = encrypted_str:sub(1, separator_index - 1)
    local encrypted_data = encrypted_str:sub(separator_index + 1)
    return key, encrypted_data
end

local function custom_decrypt(encrypted_data, key)
    local decrypted = {}

    for i = 1, #encrypted_data do
        local char = encrypted_data:sub(i, i)
        local key_char = key:sub((i % #key) + 1, (i % #key) + 1)
        local original_char = string.char(((char:byte() ~ key_char:byte()) % 94) + 33) -- Reverse XOR with key
        table.insert(decrypted, original_char)
    end

    return table.concat(decrypted, "")
end

return function(encrypted_str)
    local key, encrypted_data = extract_parts(encrypted_str)
    if not key or not encrypted_data then return error("Invalid encrypted string") end
    local decrypted_code = custom_decrypt(encrypted_data, key)
    return loadstring(decrypted_code)
end
