local function extract_parts(encrypted_str)
    local separator_index
    for i = 1, #encrypted_str do
        local char = encrypted_str:sub(i, i)
        if char:match("[%p]") then -- Detects first punctuation mark (separator)
            separator_index = i
            break
        end
    end

    if not separator_index then return nil, nil end -- If no separator found, return nil
    local key = encrypted_str:sub(1, separator_index - 1)
    local encrypted_data = encrypted_str:sub(separator_index + 1)
    return key, encrypted_data
end

local function custom_decrypt(encrypted_data, key)
    local key_shifts = {}
    for shift in key:gmatch("%d+") do
        table.insert(key_shifts, tonumber(shift))
    end

    local decrypted = {}
    local encrypted_numbers = {}
    for num in encrypted_data:gmatch("%d+") do
        table.insert(encrypted_numbers, tonumber(num))
    end

    for i = 1, #encrypted_numbers do
        local shift = key_shifts[(i % #key_shifts) + 1]
        local original_char = string.char(((encrypted_numbers[i] - shift) % 256)) -- Reverse shift
        table.insert(decrypted, original_char)
    end

    return table.concat(decrypted, "")
end

return function(encrypted_str)
    local key, encrypted_data = extract_parts(encrypted_str)
    if not key or not encrypted_data then return error("Invalid encrypted string") end
    local decrypted_code = custom_decrypt(encrypted_data, key)
    return loadstring(decrypted_code)
end
